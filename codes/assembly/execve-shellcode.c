#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// The syscall number is placed in eax, then each parameters in ebx, ecx, edx. 
// And finally "int 0x80" is the instruction which makes the system call work.
// The return value can be collected from eax

// int execve(const char *filename, char *const argv[], char *const envp[]);

/*
EAX Accumulator for operands and results data
EBX Pointer to data in the DS segment
ECX Counter for string and loop operations
EDX I/O pointer
ESI Pointer to data in the segment pointed to by the DS register; source pointer for string operations
EDI Pointer to data (or destination) in the segment pointed to by the ES register; destination pointer for string operations
ESP Stack pointer (in the SS segment)
EBP Pointer to data on the stack (in the SS segment)
*/

// http://www.safemode.org/files/zillion/shellcode/doc/Writing_shellcode.html

/*
execve assembly
char *ss = 0;
__asm__("jmp callit;\n"
	"doit:\n"
	"pop %%esi;\n"
	"xor %%eax,%%eax;\n"
	"movb %%al, 8(%%esi);\n"
	"leal (%%esi), %%ebx;\n"
	"movl %%ebx, 8(%%esi);\n"
	"movl %%eax, 12(%%esi);\n"
	"movb $0x0b, %%al;\n"
	"movl %%esi, %%ebx;\n"
	"leal 8(%%esi), %%ecx;\n"
	"leal 12(%%esi), %%edx;\n"
	"int $0x80;\n"
	"callit:\n"
	"call doit;\n"
	".string \"/bin/ls#AAAABBBB\""
	:"=&S" (ss)
	);
*/

char shellcode[] = 
	"\xeb\x1a\x5e\x31\xc0\x88\x46\x08\x8d\x1e\x89\x5e\x08\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d"
	"\x56\x0c\xcd\x80\xe8\xe1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x6c\x73\x23\x41\x41\x41\x41\x42\x42\x42\x42";

void overflow()
{
  write(2, "overflow\n", 9);
}
void (*fp)(void) = overflow;

int main(int argc, char *argv[])
{
  char str[4] = {0};
  //  memcpy(str+4, &overflow, 4);
  
  str[atoi(argv[1])] = fp;

	
  return 0;
}
